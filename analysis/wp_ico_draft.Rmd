---
title: "Does Whitepaper Page Count Affect ICO Valuation?"
author: "Michael Rosenberg and Michael McCaffrey"
date: "11/22/2018"
output: pdf_document
---

```{r setup, include=FALSE}
base_dir <- "~/Dropbox/repos/page_count_crypto_analysis"
knitr::opts_chunk$set(echo = TRUE,
                      root.dir = base_dir)
#packages
library(lubridate)
library(tree)
library(ggplot2)
library(gridExtra)
library(knitr)

#helper constants
pch_lev <- 19
percent_lev <- 100
num_breaks_per_hist <- 5
alpha_lev <- .5
who_am_i <- 24601
num_folds <- 5
block_hexcolor <- "#00BDBB"
```

```{r helper_functions,include=FALSE}
#plotting helpers
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  #adapted from http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

get_xlab_for_hist <- function(ico_df,var_name,var_label,round_lev = 1){
    #Helper function for getting the string for the xlabel of a histogram for
    #the var_name of interest.
    #get statistics
    var_mean <- round(mean(ico_df[,var_name]),round_lev)
    var_min <- round(min(ico_df[,var_name]),round_lev)
    var_max <- round(max(ico_df[,var_name]),round_lev)
    #get strings to add
    mean_str <- paste("Mean =",var_mean,sep = " ")
    range_str <- paste("Range = [",var_min,",",var_max,"]",sep = " ")
    xlab_str <- paste(var_label,
                      "(",
                      mean_str,
                      ",",
                      range_str,
                      ")",
                      sep = " ")
    return(xlab_str)
}

#modeling helpers
get_cross_val_rmse <- function(wp_ico_frame,formula_str,fold_var){
    #helper for getting cross-validated RMSE (in untransformed terms) for our
    #given dataset
    fold_vec <- wp_ico_frame[,fold_var]
    rmse_vec <- c()
    for (fold_num in unique(fold_vec)){
        #filter
        at_fold_num <- (fold_vec == fold_num)
        test_frame <- wp_ico_frame[at_fold_num,]
        train_frame <- wp_ico_frame[!at_fold_num,]
        #then fit
        train_lm <- lm(formula_str,data = train_frame)
        #then test
        test_pred <- predict(train_lm,newdata = test_frame)
        #then transform
        test_nonlogged_pred <- exp(test_pred)
        target_var_name <- strsplit(formula_str," ")[[1]][1]
        test_nonlogged_actuals <- exp(test_frame[,target_var_name])
        #get rmse
        test_rmse <- sqrt(mean((test_nonlogged_actuals - test_nonlogged_pred) ** 2))
        rmse_vec <- c(rmse_vec,test_rmse)
    }
    return(mean(rmse_vec))
}
```

```{r set_up_figure_dir,include=FALSE}
#get base figure directory
base_figure_dir <- paste(base_dir,"figures",sep = "/")
dir.create(base_figure_dir,showWarnings = FALSE)
#get analysis-specific figure directory
analysis_figure_dir <- paste(base_figure_dir,"page_count_analysis",sep = "/")
dir.create(analysis_figure_dir,showWarnings = FALSE)
```

```{r load_data,include=FALSE}
wp_ico_frame <- read.csv(
    paste(base_dir,"data/preprocessed/cleaned_wp_ico.csv",sep = "/"),
    header = TRUE)
```

# Introduction {#introduction}

Within the cryptocurrency markets, there has been a [recent uptick in whitepaper
length](https://www.longhash.com/news/why-ico-white-papers-keep-getting-longer).
Between Q1 2016 and Q4 2018, the word count has increased from around 3000 words
per paper to 9000 words per paper. Many ICO projects slated to launch in 2019
look to be continuing this trend.

We are interested in seeing if this length increase informs any ICO valuation
processes. In particular, does whitepaper length predict higher ICO valuations
by close date?

Our intuition suggests that whitepaper length might be an indication of ICO
complexity. On one hand, this complexity might be a sign of innovative work,
which would imply a higher  **(FILL INFORMATION IN HERE)**

To analyze this question, we collected amount raised as close date per
cryptocurrency via [Coindesk's ICO Tracker](https://www.coindesk.com/ico-tracker).
We then manually looked up each cryptocurrency's whitepaper and identified the
page count on those papers. Due to the work-intensive nature of that manual
process, we decided to solely analyze ICOs between January 2018 and July 2018.
We will discuss the implications of this data subsetting in our [next steps](
#next_steps).

# Data Exploration {#data_exploration}

Within our dataset, there are around `r dim(wp_ico_frame)[1]` ICOs between
January and July of this year. This dataset size is relatively small, which
suggests that we may not be powered to see statistically significant results
with a large feature set. We may be able to do a more in-depth analysis when we
consider earlier years in our [future work](#next_steps).

For our analysis, we will be predicting the amount raised in ICO (in millions)
per cryptocurrency using page count. Let's take a look at our variables of
interest.

```{r plot_amount_raised,echo=FALSE,message=FALSE}
#cleanup from dollar to numeric
wp_ico_frame$amount_raised_m <- as.numeric(gsub('[$,]', '',
                                           wp_ico_frame$Amount.Raised.in.ICO...M.))

#plot
non_transformed_hist <- (
    ggplot(data = wp_ico_frame, aes(amount_raised_m))
        + geom_histogram(col = block_hexcolor,
                         fill = block_hexcolor)
        + xlab(get_xlab_for_hist(wp_ico_frame
                              , "amount_raised_m"
                              , "Amount Raised ($M)"
               )
        )
        + ylab ("Count")
        + ggtitle("Distribution of Amount Raised ($M)")
        + theme_bw()
)
log_transformed_hist <- (
    ggplot(data = wp_ico_frame, aes(log(amount_raised_m)))
        + geom_histogram(col = block_hexcolor,
                         fill = block_hexcolor)
        + xlab("Log-Amount Raised ($M)")
        + ylab ("Count")
        + ggtitle("Distribution of Log-Amount Raised ($M)")
        + theme_bw()
        + scale_x_continuous(breaks = round(seq(min(log(wp_ico_frame$amount_raised_m)), 
                                                max(log(wp_ico_frame$amount_raised_m)),
                                                length.out = num_breaks_per_hist),1))
)
ggsave(paste(analysis_figure_dir,"amount_raised_hist.png",sep = "/"),
       arrangeGrob(non_transformed_hist,log_transformed_hist))
multiplot(non_transformed_hist,log_transformed_hist)
```
_Figure 1: Distribution of Amount Raised in ICO ($M). The regular amount raised
is on the top, while the log-amount raised is on the bottom._

We see that the raw amount raised is very right-skewed (top). This is typical of
financial data; there are many ICOs that have raised relatively little by their
close date and a handful of ICOs that have raised a huge amount of money. For
reference, the median amount raised is around
\$`r round(median(wp_ico_frame$amount_raised_m),1)`M while the max is around
\$`r round(max(wp_ico_frame$amount_raised_m),1)`M. While this is perfectly reasonable
as a financial process, it is often difficult for simple predictive models to
fit right-skewed variables. Because the [natural logarithm](https://en.wikipedia.org/wiki/Logarithm)
of amount raised is much more normally distributed (which tends to be easier to
predict with simple regression methods), we will aim to predict the
log-transformed version of our amount raised in our [methodology](#methodology).

```{r plot_page_count_dist,echo=FALSE,message=FALSE}
page_count_hist <- (
    ggplot(data = wp_ico_frame, aes(Page.count))
        + geom_histogram(col = block_hexcolor,
                         fill = block_hexcolor)
        + xlab(get_xlab_for_hist(wp_ico_frame
                                  , "Page.count"
                                  , "Page Count"
               )
        )
        + ylab ("Count")
        + ggtitle("Distribution of Page Count Across Whitepapers")
        + theme_bw()
        + scale_x_continuous(breaks = round(seq(min(wp_ico_frame$Page.count), 
                                                max(wp_ico_frame$Page.count),
                                                length.out = num_breaks_per_hist),0))
)
ggsave(paste(analysis_figure_dir,"page_count_hist.png",sep = "/"),
       page_count_hist)
page_count_hist
```

_Figure 2: Distribution of Page Count per ICO whitepaper._

Like amount raised, page count is also a right-skewed variable. On average,
ICO whitepapers tend to be around `r round(mean(wp_ico_frame$Page.count),1)`,
but the longest whitepaper in our dataset is around `r round(max(wp_ico_frame$Page.count),1)` pages. Since most simple regression
methods make no normality assumptions about explanatory variables, I am not too
concerned about this. However, the sparsity of the page count distribution above
70 pages suggests that we may not currently be able to make statistically
meaningful statements about very long whitepapers.

```{r prepare_assets_for_bivariate_plot_analysis,echo=FALSE,message=FALSE}
#calculate some cutoff information
test_cutoff <- 54
wp_ico_frame$above_cutoff <- (wp_ico_frame$Page.count >= test_cutoff)
#outlier values
outlier_row <- which.max(wp_ico_frame$Page.count)
outlier_page_count <- wp_ico_frame$Page.count[outlier_row]
outlier_log_amt_raised <- log(wp_ico_frame$amount_raised_m[outlier_row])
offset_x <- 10
offset_y <- 1
#get rid of outlier
outlier_removed_ico_frame <- wp_ico_frame[-outlier_row,]
#get some notes pre- and post-cutoff
mean_log_amt_raised_pre_cutoff <- mean(
                                       log(
                            outlier_removed_ico_frame$amount_raised_m[!outlier_removed_ico_frame$above_cutoff]
                                       )
)
mean_log_amt_raised_post_cutoff <- mean(
                                       log(
                            outlier_removed_ico_frame$amount_raised_m[outlier_removed_ico_frame$above_cutoff]
                                       )
)
mean_amount_lift <- (
    (exp(mean_log_amt_raised_post_cutoff) / exp(mean_log_amt_raised_pre_cutoff)) - 1
)
presentable_lift <- round(mean_amount_lift * percent_lev,2)
#get percentile transformation
#normalize cutoff
min_page_count <- min(outlier_removed_ico_frame$Page.count)
max_page_count <- max(outlier_removed_ico_frame$Page.count)
norm_test_cutoff <- (
                        ((test_cutoff - min_page_count)
                         / (max_page_count - min_page_count)
                        ) * percent_lev
)
```

```{r bivariate_plot,echo=FALSE,message=FALSE}
#then plot
log_amt_raised_on_page_count_plot <- (
    ggplot(data = wp_ico_frame,aes(x = Page.count
                                 , y = log(amount_raised_m)
                               )
    )
        + geom_point(col = block_hexcolor
                   , fill = block_hexcolor
                   , alpha = alpha_lev
        )
        #get linear predictor
        + geom_smooth(method = "lm"
                    , se = FALSE
                    , data = outlier_removed_ico_frame
        )
        #get cutoff at test
        + geom_vline(xintercept = test_cutoff
                   , col = "black"
                   , linetype = "dashed"
                   , alpha = alpha_lev - .1)
        #get group means
        + geom_smooth(aes(y = log(amount_raised_m),group = above_cutoff)
                    , formula = y ~ 1
                    , method = "lm"
                    , col = "red"
                    , linetype = "dashed"
                    , se = FALSE
                    , data = outlier_removed_ico_frame
        )
        #point out outlier
        + annotate("text"
                 , x = outlier_page_count - offset_x
                 , y = outlier_log_amt_raised - offset_y
                 , label = "Outlier"
                 , fontface = 2
                 , vjust = 1
                 , hjust = .5
        )
        + annotate("segment"
                 , x = outlier_page_count - offset_x
                 , y = outlier_log_amt_raised - offset_y
                 , xend = outlier_page_count
                 , yend = outlier_log_amt_raised
                 , size = .5
                 , alpha = alpha_lev + .1
                 , arrow = arrow()
        )
        #scale ticks
        + scale_x_continuous(breaks = round(seq(min(wp_ico_frame$Page.count)
                                              , max(wp_ico_frame$Page.count)
                                              , length.out = num_breaks_per_hist
                                            )
                                          , 0
                                      )
        )
        + scale_y_continuous(breaks = round(seq(min(log(wp_ico_frame$amount_raised_m))
                                              , max(log(wp_ico_frame$amount_raised_m))
                                              , length.out = num_breaks_per_hist
                                            )
                                          , 0
                                      )
        )
        #label and theme
        + theme_bw()
        + xlab("Page Count")
        + ylab("Log-Amount Raised ($M)")
        + ggtitle("Log-Amount Raised ($M) on Page Count")
)
ggsave(paste(analysis_figure_dir,"log_amt_raised_on_page_count.png",sep = "/"),
       log_amt_raised_on_page_count_plot)
log_amt_raised_on_page_count_plot
```

_Figure 3: Log-Amount Raised ($M) on Page Count (teal). We have removed the
page count outlier (Page Count = `r max(wp_ico_frame$Page.count)`) from
annotation within the plot. The blue line represents the linear trend for the
core ICO set. The dashed black line represents the page count of
`r test_cutoff`, while the red dashed lines represent the mean log-Amount raised
pre-cutoff and post-cutoff._

When plotting log-amount raised on page count, there is a very clear outlier
at around `r max(wp_ico_frame$Page.count)` pages. Given that the second largest
page count is only around `r max(outlier_removed_ico_frame$Page.count)` pages
and the amount raised at the `r max(wp_ico_frame$Page.count)`-page whitepaper
is very high, I feel uncomfortable interpolating the page count effect within 
this gap. Thus, we are going to remove the `r max(wp_ico_frame$Page.count)`-page
whitepaper from our analysis.

By the linear trend (blue), we see that there is a key positive relationship
between increased page counts and amount raised. However, it is also clear based
on our observations (teal), the noise around the linear trend is non-constant.
In particular, it looks like the variation of log-amount raised decreases after
around `r test_cutoff` pages. This [heteroscedasticity](https://en.wikipedia.org/wiki/Heteroscedasticity)
may violate some of the assumptions around statistically testing the
relationship between log-amount raised and page count. Due to our timeline, we
leave this robustness check outside the scope of this analysis. We will review
the implications in our [next steps](#next_steps).

When analyzing this relationship, we also noticed a clear conditional lift in
log-amount raised at around the `r test_cutoff`-page mark. If we just analyze
mean amount raised pre-cutoff and post-cutoff, we measure around a
`r presentable_lift`\% lift in amount raised. While this measurement will
likely be dampened when controlling for other sources of variation (see
[methodology](#methodology)), this lift seems substantial enough to be
considered as an alternative predictive hypothesis to a linear trend (blue).
While the `r test_cutoff` number is relatively arbitrary, it corresponds with
the `r round(norm_test_cutoff,0)`th percentile of the page count distribution.
Thus, we will consider a model that represents the page count effect on
log-amount raised as a lift around and above the median page count.

# Methodology {#methodology}

*(FILL METHODOLOGY HERE)*

```{r filter_dataset,include=FALSE}
outlier_row <- which.max(wp_ico_frame$Page.count)
filtered_wp_ico_frame <- wp_ico_frame[-outlier_row,]
```

```{r engineer_features_for_method,include=FALSE}
#target
filtered_wp_ico_frame$log_amount_raised_m <- log(filtered_wp_ico_frame$amount_raised_m)
#features
filtered_wp_ico_frame$month_of_close <- month(
                                    as.POSIXct(filtered_wp_ico_frame$ICO.Close.Date,
                                               format = "%m/%d/%y"))
#normalize page count
min_page_count <- min(filtered_wp_ico_frame$Page.count)
max_page_count <- max(filtered_wp_ico_frame$Page.count)
norm_page_count <- ((filtered_wp_ico_frame$Page.count - min_page_count)
                    / (max_page_count - min_page_count))
page_percentile <- norm_page_count * percent_lev
filtered_wp_ico_frame$page_count_percentile <- page_percentile
#transform cutoff
test_cutoff <- 54
norm_test_cutoff <- (
                        ((test_cutoff - min_page_count)
                         / (max_page_count - min_page_count)
                        ) * percent_lev
)
filtered_wp_ico_frame$above_cutoff <- (filtered_wp_ico_frame$page_count_percentile >= norm_test_cutoff)
```

```{r prepare_for_crossval,include=FALSE}
#generate fold var
set.seed(who_am_i)
fold_levels <- 1:num_folds
fold_vec <- rep(fold_levels,length.out = dim(filtered_wp_ico_frame)[1])
#permute
fold_vec <- sample(fold_vec)
filtered_wp_ico_frame$fold <- fold_vec
```

```{r, get_cv_rmse,echo=FALSE,message=FALSE}
linear_formula <- "log_amount_raised_m ~ Page.count + as.factor(month_of_close)"
binary_formula <- "log_amount_raised_m ~ above_cutoff + as.factor(month_of_close)"
linear_cv_rmse <- get_cross_val_rmse(filtered_wp_ico_frame,linear_formula,"fold")
binary_cv_rmse <- get_cross_val_rmse(filtered_wp_ico_frame,binary_formula,"fold")
```

# Results {#results}

```{r chosen_mod,echo=FALSE,message=FALSE}
final_mod_lm <- lm(log_amount_raised_m ~ Page.count + as.factor(month_of_close)
                 , data = filtered_wp_ico_frame
)
#save model
model_dir <- paste(base_dir,"models",sep = "/")
dir.create(model_dir)
saveRDS(final_mod_lm,paste(model_dir,"final_mod_lm.rds",sep = "/"))
```

```{r study_model,echo=FALSE,message=FALSE}
#get table
summary_table <- as.data.frame(summary(final_mod_lm)$coefficients)
#clean
summary_table$Percent_Change <- (exp(summary_table$Estimate) - 1) * percent_lev
scientific_rounding <- 3
kable(round(summary_table,scientific_rounding))
```

```{r check_for_multicollinearity,echo=FALSE,message=FALSE}
(
    ggplot(aes(x = month_of_close
             , y = Page.count
           )
         , data = filtered_wp_ico_frame
    )
    + geom_point(col = block_hexcolor
               , fill = block_hexcolor
               , alpha = alpha_lev
    )
    + stat_summary(fun.y = mean
                 , color = "blue"
                 , geom = "line"
                 , group = 1
    )
)
```

# Next Steps {#next_steps}
